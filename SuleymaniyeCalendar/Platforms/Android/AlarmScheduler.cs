using System;
using System.Collections.Generic;
using Android.App;
using Android.Content;
using Android.OS;
using Java.Util;
using Microsoft.Maui.Storage;
using Application = Android.App.Application;

namespace SuleymaniyeCalendar;

internal static class AlarmScheduler
{
    private const string NotificationReceiverExtraName = "name";
    private const string NotificationReceiverExtraTime = "time";

    private static readonly IReadOnlyDictionary<string, int> RequestCodeOffsets = new Dictionary<string, int>
    {
        {"Fecri Kazip", 1000},
        {"Fecri Sadık", 2000},
        {"Sabah Sonu", 3000},
        {"Öğle", 4000},
        {"İkindi", 5000},
        {"Akşam", 6000},
        {"Yatsı", 7000},
        {"Yatsı Sonu", 8000}
    };

    private static readonly IReadOnlyDictionary<string, int> CancelOffsets = new Dictionary<string, int>
    {
        {"FalseFajr", 1000},
        {"Fajr", 2000},
        {"Sunrise", 3000},
        {"Dhuhr", 4000},
        {"Asr", 5000},
        {"Maghrib", 6000},
        {"Isha", 7000},
        {"EndOfIsha", 8000}
    };

    // Schedules an alarm clock style PendingIntent for a specific prayer instance.
    internal static void SchedulePrayer(DateTime date, TimeSpan triggerTimeSpan, int timeOffsetMinutes, string name)
    {
        try
        {
            var alarmManager = (AlarmManager)Application.Context.GetSystemService(Context.AlarmService);
            if (alarmManager is null)
            {
                System.Diagnostics.Debug.WriteLine("AlarmScheduler: AlarmManager unavailable");
                return;
            }

            using var calendar = Calendar.Instance;
            var adjustedTrigger = triggerTimeSpan - TimeSpan.FromMinutes(timeOffsetMinutes);
            if (adjustedTrigger < TimeSpan.Zero)
            {
                adjustedTrigger = TimeSpan.Zero;
            }

            calendar.Set(date.Year, date.Month - 1, date.Day, adjustedTrigger.Hours, adjustedTrigger.Minutes, 0);

            var requestCode = ResolveRequestCode(name, date.DayOfYear);
            var flags = Build.VERSION.SdkInt > BuildVersionCodes.R
                ? PendingIntentFlags.UpdateCurrent | PendingIntentFlags.Immutable
                : PendingIntentFlags.UpdateCurrent;

            var broadcastIntent = new Intent(Application.Context, typeof(AlarmNotificationReceiver))
                .PutExtra(NotificationReceiverExtraName, name)
                .PutExtra(NotificationReceiverExtraTime, triggerTimeSpan.ToString())
                .AddFlags(ActivityFlags.IncludeStoppedPackages | ActivityFlags.ReceiverForeground);

            var pendingIntent = PendingIntent.GetBroadcast(Application.Context, requestCode, broadcastIntent, flags);
            var showIntent = BuildShowIntent(requestCode, flags);
            var info = new AlarmManager.AlarmClockInfo(calendar.TimeInMillis, showIntent);
            alarmManager.SetAlarmClock(info, pendingIntent);

            System.Diagnostics.Debug.WriteLine($"AlarmScheduler: scheduled {name} for {date:dd/MM/yyyy} at {adjustedTrigger}");
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"AlarmScheduler.SchedulePrayer failed: {ex.Message}\n{ex.StackTrace}");
        }
    }

    // Cancels all alarms generated by the scheduler within a safe date window.
    internal static void CancelAll()
    {
        try
        {
            var alarmManager = (AlarmManager)Application.Context.GetSystemService(Context.AlarmService);
            if (alarmManager is null)
            {
                return;
            }

            var lookupFlags = Build.VERSION.SdkInt > BuildVersionCodes.R
                ? PendingIntentFlags.NoCreate | PendingIntentFlags.Immutable
                : PendingIntentFlags.NoCreate;

            var start = DateTime.Today.AddDays(-2);
            var end = DateTime.Today.AddDays(60);

            for (var cursor = start; cursor <= end; cursor = cursor.AddDays(1))
            {
                foreach (var offset in CancelOffsets.Values)
                {
                    var requestCode = cursor.DayOfYear + offset;
                    var intent = new Intent(Application.Context, typeof(AlarmNotificationReceiver));
                    var pendingIntent = PendingIntent.GetBroadcast(Application.Context, requestCode, intent, lookupFlags);
                    if (pendingIntent is null)
                    {
                        continue;
                    }

                    try
                    {
                        alarmManager.Cancel(pendingIntent);
                        pendingIntent.Cancel();
                    }
                    catch (Exception ex)
                    {
                        System.Diagnostics.Debug.WriteLine($"AlarmScheduler.CancelAll: failed for {requestCode}: {ex.Message}");
                    }
                }
            }

            Preferences.Set("LastAlarmDate", string.Empty);
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"AlarmScheduler.CancelAll error: {ex.Message}");
        }
    }

    // Builds the show intent launched by the system clock UI when the alarm fires.
    private static PendingIntent BuildShowIntent(int requestCode, PendingIntentFlags flags)
    {
        var packageManager = Application.Context.PackageManager;
        var launchIntent = packageManager?.GetLaunchIntentForPackage(Application.Context.PackageName) ??
                           new Intent(Application.Context, typeof(MainActivity));
        launchIntent.SetFlags(ActivityFlags.SingleTop | ActivityFlags.ClearTask);

        return PendingIntent.GetActivity(Application.Context, requestCode, launchIntent, flags);
    }

    // Generates a unique request code per prayer/day combination.
    private static int ResolveRequestCode(string name, int dayOfYear)
    {
        if (!string.IsNullOrWhiteSpace(name) && RequestCodeOffsets.TryGetValue(name, out var offset))
        {
            return dayOfYear + offset;
        }

        return dayOfYear;
    }
}
